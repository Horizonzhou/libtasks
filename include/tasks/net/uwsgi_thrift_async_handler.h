/*
 * Copyright (c) 2013-2014 ADTECH GmbH
 * Licensed under MIT (https://github.com/adtechlabs/libtasks/blob/master/COPYING)
 *
 * Author: Andreas Pohl
 */

#ifndef _UWSGI_THRIFT_ASYNC_HANDLER_H_
#define _UWSGI_THRIFT_ASYNC_HANDLER_H_

#include <tasks/net/uwsgi_task.h>
#include <string>
#include <functional>
#include <memory>

namespace tasks {
namespace net {

template <class thrift_result_type,  // generated by thrift
          class thrift_args_type>    // generated by thrift
class uwsgi_thrift_async_handler : public tasks::error_base {
  public:
    typedef std::function<void()> handler_finish_func_t;
    typedef thrift_result_type result_t;
    typedef thrift_args_type args_t;

  private:
    result_t m_result;
    uwsgi_task* m_uwsgi_task = nullptr;
    handler_finish_func_t m_finish_func;

  protected:
    // Provide some wrappers to access the request and response structures
    // from a service call implementation.
    inline uwsgi_request& request() { return m_uwsgi_task->request(); }

    inline uwsgi_request* request_p() { return m_uwsgi_task->request_p(); }

    inline http_response& response() { return m_uwsgi_task->response(); }

    inline http_response* response_p() { return m_uwsgi_task->response_p(); }

    // Async handlers call this method to trigger the processor callback
    inline void finish() { m_finish_func(); }

  public:
    virtual ~uwsgi_thrift_async_handler() {}
    virtual void service(std::shared_ptr<args_t> args) = 0;
    virtual std::string service_name() const = 0;

    inline result_t& result_base() { return m_result; }

    inline auto result() -> decltype((m_result.success)) { return m_result.success; }

    inline void set_uwsgi_task(uwsgi_task* t) { m_uwsgi_task = t; }

    inline void on_finish(handler_finish_func_t f) { m_finish_func = f; }
};

}  // net
}  // tasks

#endif  // _UWSGI_THRIFT_ASYNC_HANDLER_H_
